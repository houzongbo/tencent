一·. 数据结构
	string	hash	set	list	zset

二. 高并发原理
	1. 纯内存数据库，读取速度快
	2. 非阻塞io，io多路复用
	3. 单线程模型，保证操作原子性
	4. 数据结构特殊设计	跳跃表（多指针链表）
	
	跳表：可以二分查找的链表（空间换时间），引入多层级概念，每个上层作为下层的索引
		每个上层插入元素按照概率随机
					时间复杂度O(logn)，期望层数log1/p n  平均查找长度 (log1/p n -1)/p
	
	慢查询日志：slowlog get/len/reset	slowlog-max-len	slowlog-log-slower-than
	
	pipeline 流水线机制：批量操作，减少网络请求

三. 事务
	1. multi和exec命令	multi代表事务开始	exec代表事务结束
		·不支持回滚
		·不满足原子性，其他操作也可以修改key
		·命令相互独立，后执行无法以来先执行结果
		·每个命令都要与redis服务器交互，超时影响大
	2. lua脚本
		 eval "return redis.call('set',KEYS[1],'bar')" 1 foo 

四. 数据持久化
	将数据备份到磁盘，防止重启后内存丢失。
	
	1. RDB:	定期将内存快照写入磁盘（内存数据二进制序列化），fork一个子进程来完成。
	2. AOF:	实时记录写指令，重启后再再执行一遍回放。AOF瘦身 防止AOF过大。
	3. 混合持久化：AOF在重写瘦身的时候，通过RDB格式记录，再补充瘦身期间的AOF记录

五. 主从架构	maste-slave
	1. 缩短不可用时间：master宕机，slave升级
	2. 读写分离，提升读性能：多个slave负责度请求
	
六. 哨兵机制
	引入观察者监控master状态，定期轮询master是否正常，异常就主从切换
	
	设置多个哨兵，防止误判。一个哨兵异常就询问其他哨兵，如果都异常就说明master故障。
	哪个哨兵发起主从切换？
		选取哨兵领导者，raft算法。

七：分片集群，横向扩展
	分布式架构，解决写压力
	每个节点只存储一部分数据，而不是全部存储。
	通过路由，把操作key找到正确实例。twemproxy	redis cluster(节点间Gossip协议通信，无需哨兵)


八：缓存
	缓存更新策略：1. 算法LRU最近最少使用	数据一致性差，实现简单
		      2. 超时删除，引入过期时间	也分为定期删除，惰性删除
		      3. 主动更新	一致性高

	？缓存穿透：查询数据库不存在数据时，缓存失去意义，每次请求都会打到数据库。
		   *1. 布隆过滤器：将可能存在的数据哈希到一个bitmap，进行拦截
		   *2. 对空结果也进行缓存，过期时间尽量短
	
	？缓存雪崩：过期时间设置相同，大量缓存同时失效。每个过期时间增加随机值。

	？缓存预热：系统刚开始，缓存未准备好。这个时候应该事先把热key先预存到缓存。
	
	？缓存击穿：对于某一热key的保护，互斥锁，永不过期
	
	？缓存一致性：缓存更新和缓存删除的取舍，看缓存更新是否开销大

			先数据库还是先缓存？	延时双删策略
