一·. 数据引擎
	1. MyISAM	frm文件：存储表的定义
			MYD文件：存储表记录的数据
			MYI文件：存储索引

	2. InnoDB		事务型存储引擎，默认存储引擎
		1. 可自动增长列
		2. 支持事务	默认可重复读，通过MVCC（并发版本控制）
		3. 行级锁，支持高并发
		4. 支持外键，增加耦合
		5. 物理组织形式是聚簇表，按照主键组织。数据和索引都在B+树叶子节点上

二. 三范式
	1. 所有字段都是单一属性不可再分
	2. 必须有主键
	3. 非主键之间不能相互依赖

三. SQL索引
	索引优点：减少服务器扫描数据行数；帮助排序，分组；随机io转为顺序io
	索引使用条件：中到大型表；特大型表建议分区
		

	
	B+树：
		非叶子节点中的key，左子树key小于它，右子树的key大于等于它（父节点的key会复制到右子树上）	
		叶子节点之间有指针相连，左叶子指向右叶子（排序）
	B树和B+树？
		1. B树只适合随机索引，B+树支持随机检索和顺序检索（排序）
		2. B+树磁盘读写代价低，数据存在叶子节点
		3. B+树查询效率稳定，B树有可能在非叶子节点结束

	B+树和红黑树：
		1. B+树节点能存多元素，高度低 磁盘io次数少
		2. B+树，非叶子节点设置为页大小，能让磁盘一次io读取整个节点数据

	B+聚簇索引：
		数据存储在叶子节点，主键默认聚簇索引

	非聚簇索引：普通索引，唯一索引，全文索引
		叶子节点只存主键值，查询其他字段得二次查询（回表）

四. join连表
	1. INNER JOIN	获取两个表字段匹配关系的记录
	2. LEFT JOIN	获取左表所有记录，右表返回匹配的记录
	3. RIGHT JOIN	获取右表所有记录，左表返回匹配记录
		
五. 排序 order by
	1. 通过索引扫描生成有序结果
	2. 先筛选，在排序	

六. 优化
	1. 索引优化		
		· 索引列不能是表达式
		· 多列索引，适用于复合条件查询
		· 索引顺序，最左前缀原则（区分度）
		· 前缀索引，对于特定类型，字段过长，只能取前缀
		· 覆盖索引，索引包含所有查询字段的值
	2. 查询select性能优化
		explain语句：select_type, table, possible_keys, key, rows, type, 
		type: 索引类型，const 主键匹配唯一，ref非主键索引，range 索引匹配范围，index排序，覆盖索引，all，
	3. 优化sql
		·行用limit限制；列只返回需要的 不用*； 缓存
		·索引覆盖查询和主键查询
			
七. 慢查询分析
	explain分析
	show profile查看执行耗时

	原因：
		1. 索引使用不当
			· 字段类型不等，索引失效
			· where order by没命中索引
			· 索引区分度低（最左）   比如性别
			· order by 范围查询（不同字段），索引有序性无法利用
			· or 语句  会全表扫描
		2. 死锁
			· update，delete以二级索引字段为条件可能引发死锁
				
				两个操作都获取了间隙锁，但是插入意向锁相互等待

		分页时 limit 10000，100
			深度分页

八. 乐观锁 悲观锁
	乐观锁：假设不会发生冲突，只在提交操作时，检查是否违反完整性；版本号实现select快照读
	悲观锁：假设会发生冲突，屏蔽一切违反完整性操作；使用数据库提供的锁机制，排他锁；关闭自动提交；
		InnoDB默认行级锁，基于索引，但如果没有索引就是表级锁
	

九. drop、delete与truncate的区别
	drop：删除表
	delete：删除部分数据行
	truncate：删除表里所有数据

十. 什么是视图？以及视图的使用场景有哪些？

	视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。
	对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。


十一. 事务
	ACID：原子性，一致性，隔离性，持久性

十二. 隔离级别
	1. 未提交读——脏读
	
	2. 提交读——不可重复读

	3. 可重复读——幻影读

	4. 可串行化
	

十三. 锁
	类型：
		1. 共享锁（读锁）	表级锁		in share mode
		2. 排他锁（写锁）	表级锁
		3. 意向共享锁	行级锁		for update；update,delete
		4. 意向排他锁	行级锁

		行级锁：记录锁，间隙锁（范围锁，不包含本身），next-key lock（前两个组合）
			***行锁是加在索引上
			***update的where语句如果没有用上索引，就会造成全表扫描，每行加锁
			***sql_safe_updates = 1

		间隙锁：解决幻读，防止对范围内添加或删除
		next-key lock：锁范围，也锁本身  （]
		

	死锁问题：
		1. 查看死锁日志 show engine innodb status;
		2. 找出死锁sql
		3. 分析sql加锁

十四. MVCC
	
	多并发版本控制，实现提交读，可重复读隔离级别。
	
	1. 基础概念：
		·版本号：系统版本号（新开一个事务，加一）；事务版本号（事务开始时的版本号）
		·隐藏的列：
			MVCC在每行数据保存两个隐藏的列
			· 创建版本号：创建数据行快照时的系统版本号
			· 删除版本号：删除版本号需要大于当前事务版本号，否则表示快照已删除
		·Undo日志
			快照存储在Undo日志中，回滚指针把一行的所有快照连接起来
	2. 实现
		开始事务时，事务版本号一定大于所有当前数据行的创建版本号
		select：读取数据行创建版本号要小于当前事务版本号；删除版本号要大于当前事务版本号
		insert：系统版本号作为创建版本号
		delete：当前系统版本号作为删除版本号
		update：当前系统版本号作为，旧数据行快照的删除版本号，新数据行快照的创建版本号

	3. 快照读与当前读

十五. MySQL日志
	undo log	回滚日志	原子性，用于事务回滚和MVCC	在事务提交前，记录当前状态
	redo log	重做日志 	持久性，用于故障恢复
	binlog	归档日志	数据备份，主从复制

	buffer pool 缓冲池：提高读写性能，session中；写数据会将buffer数据设置脏页，异步将脏页写入磁盘
			redo log是物理日志，事务提交会把数据先缓存到buffer池，redo log放入磁盘，不用等数据加载磁盘
			redo log是追加操作，磁盘是顺序写，但是数据是随机写
	
	redo log 和 undo log的区别：
		redo：记录事务之后状态
		undo：记录事务之前的状态
	

	



