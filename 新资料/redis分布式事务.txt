1. redis事务命令组合原子执行
	
	lua脚本：事务开始-设置放重锁-读写快照-执行命令-cas版本号自增-事务结束

	？redis服务通过twemproxy代理，通过lua脚本的第一个key作为hash的key，真实要执行的命令的key作为第一个参数
	
	？redis自带multi+exec不能事务
		1. 客户端发多次请求，网络请求性能问题
		2. 多次命令 无法原子执行 超时麻烦
		3. twemproxy没有开启hashtag，分布式事务不生效，key不固定

2. redis节点超时处理， 幂等 最终一致性

	回滚：检查防重锁-处理cas版本号（redis版本与之前版本相同）- 读取快照 - 回滚至快照值 -更新防重锁的值

	回滚参数和请求参数相同，保证数据一致性


3. 事务其他节点异常时，redis如何处理
	
	1. 节点可回滚，redis也会回滚，回滚超时记录db
	2. 节点不可回滚，记录上下文，补发

4. 防悬挂处理，幂等，多次回滚重试(防重锁)

	考虑到网络的复杂性，如果redis本身的命令网络堵塞了，后续回滚的请求开始执行，然后正常的请求后到了redis服务器，如果不控制好，会造成数据不一致
	
	*防重锁-状态机
		不存在(空回滚) - 更新防重锁值no_exec
		可回滚状态 - 执行回滚 更新值rollback
		rollback - 已回滚

5. CAS版本控制，快照介绍

	为什么用cas版本信息，防重锁不够吗？
		在分布式事务中，已经有其他请求修改了，回滚可能造成问题。宁愿不回滚，不能回滚错误

	能不能通过redis最新内容和上次执行内容比较，相同就执行回滚？
		流程1中：
      		小明获得了道具A，通过redis的set命令将值设置成A道具；
    		流程2中：   
      		小明消费了道具A，通过redis的set命令将值设置成空；
    		流程3中：   
      		小王赠送了道具获得了道具A，通过redis的set命令将值设置成A道具；
		所以要通过cas版本号来控制。
	
	为什么要存快照？
		超时拿不到版本信息和快照信息，空间换取一致性保证

6. 性能对比
	原生命令和lua实现事务型命令
	对比setex 和 上面的事务 性能下降8%


Tendis SSD   	·兼容Redis协议
		·RocksDB引擎   SSD存储介质
		·持久化
		·快速扩容
		·twemproxy实现集群代理
		


