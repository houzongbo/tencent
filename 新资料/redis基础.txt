一·. 数据结构
	string	：SDS	（len,alloc,flags解决c语言缺点）
	hash	: 哈希表+压缩列表
	set	：哈希表+整数集合
	list	：双向链表+压缩列表		存放head,tail,len  减少常用方法时间复杂度；数据量少用压缩列表
	zset	：跳表+压缩列表

	哈希问题：
		哈希冲突：两个以上key被分配到同一个哈希桶
		链式哈希：每一个哈希表节点有一个next指针；一个哈希桶上的多节点用单向链表连接；长度增加明显就要rehash
		rehash：准备一个新hash表，空间大2倍；数据迁移；释放旧表，再创建新空白表准备下次rehash
		渐进式rehash：不进行主动数据迁移；在每次hash表操作过程中，将表1该索引下节点迁移到表2；
		rehash触发条件：负载因子 节点数/哈希表大小
	
	跳表：（value,score）
		可以二分查找的双向链表（空间换时间），引入多层级概念，每个上层作为下层的索引
		每个上层插入元素按照概率随机(随机层数)
					时间复杂度O(logn)，期望层数log1/p n  平均查找长度 (log1/p n -1)/p
		元素排名实现：
			span属性，表示前一个结点到当前节点中间 跳过的的节点数

二. 高并发原理
	1. 纯内存数据库，读取速度快
	2. 非阻塞io，io多路复用
	3. 单线程模型，保证操作原子性
	4. 数据结构特殊设计	跳跃表（多指针链表）
	
	慢查询日志：slowlog get/len/reset	slowlog-max-len	slowlog-log-slower-than
	
	pipeline 流水线机制：批量操作，减少网络请求

三. 事务
	1. multi和exec命令	multi代表事务开始	exec代表事务结束
		·不支持回滚
		·不满足原子性，其他操作也可以修改key
		·命令相互独立，后执行无法以来先执行结果
		·每个命令都要与redis服务器交互，超时影响大
	2. lua脚本
		 eval "return redis.call('set',KEYS[1],'bar')" 1 foo 

	3. 分布式锁的实现
		用setnx举例，原子执行expire
	
	4. 锁可能问题
		死锁：逻辑异常，没释放锁；进程挂；   解决：EXPIRE过期时间  SET lock 1 EX 10 NX
		
		提前释放锁：过期时间太短，守护线程，自动续期
		
		释放他人锁：key用唯一标识，释放前检查。检查+释放需要原子操作，LUA实现

		主从切换时锁问题：红锁（Redlock）：	1. 不再部署从库和哨兵，主库多个（大于5）
						2. 客户端在多个redis实例申请加锁
						3. 大多数实例需要加锁成功，总耗时也要小于锁过期时间
						4. 加锁失败需要释放锁
四. 数据持久化
	将数据备份到磁盘，防止重启后内存丢失。
	
	1. RDB:	定期将内存快照写入磁盘（内存数据二进制序列化），fork一个子进程来完成。
		bgsave写时复制技术，主进程和子进程共享内存，页表指向同一块内存，当主进程写操作时，物理内存复制，主进程对新内存修改，子进程继续写入原本内存数据。	***rdb不会记录执行期间命令
	2. AOF:	实时记录写指令，aof缓冲区，重启后再再执行一遍回放。		AOF瘦身 防止AOF过大。起一个子进程，读取数据库数据，将数据转换新命令。启动aof重写缓冲区
	3. 混合持久化：AOF在重写瘦身的时候，通过RDB格式记录，再补充瘦身期间的AOF记录

五. 主从架构	maste-slave
	1. 缩短不可用时间：master宕机，slave升级
	2. 读写分离，提升读性能：多个slave负责度请求

	·主从架构			
		同步复制：master写入后，还要确保所有的slave同步成功，才会返回。  强一致，高延时
		半同步复制：master只需要确保一个slave同步成功	可能幻写
		异步复制：一致性问题，可靠性低；部分场景主写主读
	
六. 哨兵机制
	引入观察者监控master状态，定期轮询master是否正常，异常就主从切换
	
	设置多个哨兵，防止误判。一个哨兵异常就询问其他哨兵，如果都异常就说明master故障。
	哪个哨兵发起主从切换？
		选取哨兵领导者，raft算法？

七：分片集群，横向扩展
	分布式架构，解决写压力
	每个节点只存储一部分数据，而不是全部存储。
	通过路由，把操作key找到正确实例。twemproxy	redis cluster(节点间Gossip协议通信，无需哨兵)


八：缓存
	缓存更新策略：1. 算法LRU最近最少使用	数据一致性差，实现简单
		      2. 超时删除，引入过期时间	也分为定期删除，惰性删除
		      3. 主动更新	一致性高

	？缓存穿透：查询数据库不存在数据时，缓存失去意义，每次请求都会打到数据库。
		   *1. 布隆过滤器：将可能存在的数据哈希到一个bitmap，进行拦截
		   *2. 对空结果也进行缓存，过期时间尽量短
	
	？缓存雪崩：过期时间设置相同，大量缓存同时失效。每个过期时间增加随机值。

	？缓存预热：系统刚开始，缓存未准备好。这个时候应该事先把热key先预存到缓存。
	
	？缓存击穿：对于某一热key的保护，互斥锁，永不过期
	
	？缓存一致性：缓存更新和缓存删除的取舍，看缓存更新是否开销大

			先数据库还是先缓存？	
			1. cache aside：	写数据库，删缓存	适合读多写少		***延时双删策略
			2. 分布式锁	影响性能
			3. 过期时间短

			写回策略：先更新缓存，批量异步更新数据库
			


九：主从一致性
	第一次同步（初始化一个slave）：slave请求建立连接进行同步，offset为-1；master通过子进程生成rdb；rdb发送给slave；slave加载rdb

	replication缓冲区：master生成rdb到最后slave加载完成期间，master收到的写命令； slave完成rdb后通知master，master发送replication

	主从建立长链接，命令传播

	增量复制：考虑到主从断联后的一致性问题，从服务器请求主服务器同步，附带了offset。

	repl_backlog_buffer: 环形缓冲区， offset代表在缓冲区偏移量； master需要判断主从之间offset差距，给从缓冲区进行增量复制的多少，以及是否需要全量复制（环形覆盖）

	主从心跳：
		master定期发送ping，监控slave状态
		slave每间隔发送offset，检测链接状态；上报偏移量，是否有数据丢失

	过期key处理：主节点如果淘汰了一个key，会模拟一个del发送给slave

	主从数据不一致： 1. 网络保证良好；2. 外部监控复制进度
	减少异步复制数据丢失：master监控和slave之间复制和同步的延时，超过后不再写入

	脑裂：master网络延时，但是没有挂掉；已经选举出了新master
		1. master必须确认有足够slave链接
		2. master监控和slave之间复制和同步的延时，超过后不再写入
		

十。 哨兵
	哨兵每隔一段时间给master发送ping

	主观下线：一个哨兵发现master失去心跳就认为下线；会误判
	客观下线：哨兵集群认为master下线； 哨兵发现master下线后会进行投票，票数大于一定值就认为客观下线

	哨兵leader：
		哨兵标记客观下线后，会成为candidate，向其他哨兵求票。每个哨兵只能投一次； 票数过半，且超过配置值，成为leader

	故障转移：
		1. 选出新master。 优先级，offset， id
		2. 新master告诉其他slave指向新master
		3. 哨兵 发布者订阅者模式通知客户端
		4. 旧master转为slave


十一。大key问题
	1. 客户端阻塞	redis单线程，操作大key会阻塞
	2. 网络阻塞	获取大key网络流量太大
	3. 内存分布不均	大key实例占用了集群大量内存


	scan寻找大key；redis-cli --bigkeys 

	删除大key：异步删除； 分批次删除



十二. 内存淘汰与过期删除

	过期删除：	惰性删除 + 定期删除
			主从同步：从库不关注过期，主库过期删除会发送del命令给从库
			rdb：校验过期时间
			aof：不校验，删除的时候会向aof加入del命令
			aof瘦身：校验

	内存淘汰：	类LRU：每个键值记录额外字段，（最后一次访问）
			LFU：解决缓存污染问题，额外记录访问频次

	

	


	



		
