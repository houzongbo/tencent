1. CAP理论 
	p:分区容忍性，网络故障，节点间无法通信，系统仍然能正常工作

2. BASE理论
	基本可用，软状态，最终一致性
	
3. 强一致性方案 -适用一致性要求高场景，如金融交易 CP
	
	2PC-二阶段提交
		1. voting 投票阶段：协调者给参与者发送prepare消息，参与者要么直接返回失败，要么本地执行事务，写本地redo undo日志，不提交。
		2. commit 提交阶段：协调者收到失败消息或超时，给参与者发回滚消息，否则发提交消息。参与者根据指令执行，释放锁

		前提条件：1. 提交阶段 网络可靠 （网络稳定性）
			2. 失联的节点能够恢复，不能永久无反应 （宕机恢复能力）
		问题：1. 单点故障：协调者故障，参与者一直等待
		          2. 同步阻塞：参与者占用公共资源时，会造成第三方节点访问资源阻塞
		          3. 数据一致性： 受限于前提条件
	
	3PC-三阶段提交
		引入超时机制，把准备阶段再分为两个阶段。
		
		1. CanCommit: 协调者发送cancommit请求，参与者返回yes no
		2. PreCommit：都是yes，就执行事务预执行precommit；有no或者超时，执行事务中断
		3. doCommit：协调者向参与者发起事务提交请求docommit；没有接受ack，执行中断

		解决了单点故障，参与者没收到协调者消息，默认commit
		还有数据一致性问题，abort指令超时，参与者还会默认commit
	
	3PC难实现，大部分2PC

4. XA协议 （资源底层分布式事务）
	
	DTP分布式事务处理模型：AP应用程序（事务发起者），RM资源管理器（事务参与者），TM事务管理器（事务协调者）
		TM和RM基于XA规范，实现2PC
	大多数实现XA都是关系型数据库和消息中间件，XA并发性能不好，无法满足高并发，使用较少。

5.本地事务状态表

	1. 调用方在执行前将事务流程和状态信息存到数据库，依赖本地事务的原子性
	2. 同步调用外部系统，每次成功会更新子事务状态
	3. 后台同步运行定时任务，定期扫描未完成事务，重新发起调用。

6. 可靠消息队列
	问题：
	1. 本地事务与消息发送的原子性
	2. 事务参与方接收消息可靠性
	3. 消息重复消费

	本地消息表，事务发起方需要记录本地消息表，通过定时任务不断push消息到中间件  kafka低版本
	事务消息    支持事务操作的中间件

7. 最大努力通知
	适用于时间敏感度低的业务，如通知等
	不可靠消息，允许丢失；定期校对，主动查询

8. TCC 适用于强隔离性的分布式事务
	Try：尝试执行阶段	尝试完成所有业务的可执行性检查，预留业务资源
	Confirm：确认执行	不检查，直接按照Try资源处理。可重复执行，保证幂等
	Cancel：取消执行	释放资源。可重复执行，保证幂等
	
	*允许空回滚
	*防悬挂	cancel早于try
	*幂等
	
	相对于2PC：1. Try阶段相对轻量，阻塞小
		   2. 用户代码层面，灵活性，根据业务锁资源

9. SAGA事务
	1. 每个SAGA事务由一系列幂等有序子序列事务组成
	2. 每个子序列事务都有对应的幂等补偿动作
	
	向前恢复： 如果 Ti 事务提交失败，则一直对 Ti 进行重试，直至成功为止（最大努力交付）
	向后恢复：如果 Ti 事务提交失败，则一直执行 Ci 对 Ti 进行补偿，直至成功为止（最大努力交付）。

           实现方式
	命令协调模式：
	事件编排模式：

	1. 无锁，高性能
	2. 异步执行，高吞吐
	3. 没有预留，没有隔离性


10 弱一致性方案   适用高可用场景（秒杀）
	

11. 柔性事务（软状态）
	

	
	