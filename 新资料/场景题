1. 定时任务调度设计

  1. 定时器实现
      维护一个最小堆（优先队列），然后将时间转换一个绝对时间处理，通过睡眠和唤醒找出定时任务

  2. 时间轮算法
      维护一个循环队列，对于每个任务，需要记录在循环队列的id，也要记录圈数

  分布式实现：    redis zset； 消息队列，延时队列
    
  设计一个订单超时未支付关闭系统：
    1. 扫表轮询：io频繁，消耗资源
    2. 懒删除：  库存不能及时恢复
    3. 消息队列：  延迟队列实现，到期进行消费    可能消息堆积，重启消息队列影响精度
    4. redis：  zset实现延迟任务score放入时间， 定期判断zset头score和当前时间
  
2. 分布式id生成

  ·数据库自增主键
  ·redis incre原子操作

  *雪花算法：64位，时间戳 + 机房id + 机器id + 毫秒级的序列数
  *解决数据库或redis单点问题： 部署多个实例，每个实例初始化值不同， 每次递增的值为实例数，保证id唯一

3. 数据库分库分表

为什么分库：  单机磁盘压力； 并发支持，分成多个功能库
为什么分表：  数据量大慢查询，3层b+树能承载2000万数据，  一般500w开始分表

垂直分库 分表：  根据业务，属性进行拆分
水平分库 分表：  减轻数据库存储 查询压力

水平分库分表策略：
  1. range  有利于扩容， 但可能有热点问题
  2. hash取模  扩容难，但没有热点问题
  3. range+hash先range分库，再hash分表

分库分表问题：
  1.事务问题：不同库需要分布式事务
  2. 排序问题： 需要业务侧合并
  3. 分布式id

4. redis热key，大key问题

    大key：数据分片，根据hash取模或者userid进行分片
          判断是否适合用redis，不合适的放入其他介质，unlink删除大key

    热key：本地缓存
          数据拆分

5. redis 数据库缓存一致性
        非频繁写：先更新数据库，再删除redis
                延时双删

        频繁写：更新数据库后更新缓存；  分布式锁，过期时间短

6. mysql慢查询


7. 消息队列
    延时消息：临时存储  +  定时任务  ，根据延时发送到相应时间的临时队列，启用定时任务轮询，时间到期就发送到真实的队列中，消费者可见
      
    事务消息：生产者和消息队列之间采用半消息的策略（类似2pc），生产者队列发送半消息，收到确认后再执行本地事务，执行成功再通知队列；后续就是消息队列和消费者进行同步；消费者消费失败有重试机制，多次失败放入死信队列

8. 限流  
    令牌桶算法

9. 限频，分布式锁
    redis setnx

    过期时间：可以用看门狗机制，定期延长过期时间
    防止释放他人锁：可将value设置成个人id，释放锁的时候需要判断，lua实现原子性
    redis本身主从同步问题：引入红锁概念，没有主从，设置5个master，大多数加锁成功认为成功
  
10. 下单系统整个流程

    防止订单重复：
      1. 前端防抖
      2. 后端幂等：   ·唯一标识符，如订单号，每次请求会查询该单号是否处理过，可用数据库或缓存记录
                    ·版本号
                    ·状态机
                    ·token机制：  客户端访问服务端，服务端生成token，存储数据库或redis，并返回给客户端；客户端提交订单时附带token，服务端成功处理后会删除token

    解决超卖问题：
      1. 悲观锁，分布式锁

      2. 预扣库存  提交订单的时候就预扣库存，利用redis原子操作

      3. 消息队列，事务消息：

      4. 限流：令牌桶算法

11. 分布式事务

    saga

    tcc

    事务消息

    最大努力交付：短信服务 通知服务，对时间不敏感业务，利用消息队列以及重试机制；    消息队列持久化消息到数据库，监控消息队列，将消息放入延时队列处理，成功标记，失败再放入延时队列
                定时任务进行数据校对，本地事务表
                人工介入

12. 异地多活


13. 海量数据问题

    分治  +  hash  +  小顶堆
    ·海量数据 频率topk：  利用hash记录每个数据访问频次， 堆排序（优先队列）； 如果量级过大，可以对先对数据hash取模，分成多个文件，再对每个文件用hash记录频次， 对每个文件求topk，最后建立堆求整体topk
        
    位图法
    ·海量数据判断是否存在：经典位图法，节省空间；  
    ·判断是否重复出现： 位图法用 00。01。10来标记。10表示多次出现

    海量数据中位数：
    ·内存充足：排序
              数据流中位数，维护两个优先队列

    ·内存不足：分治，转化二进制，根据最高位是否是1分成两个文件， 如果还是不够，再分次高位


14. 短网址系统


    短网址生成：
        1. 64位整数，借鉴雪花算法
        2. 长度不超过7的字符串，由大小写字母加数字共62个字母组成

    长短映射：
        一对多：多个短对应一个长，具有分析价值

    存储关系：
        关系数据库：mysql
        kv数据库：redis

    重定向：
      301永久重定向：不会收集到短网址信息，直接定向
      302临时重定向：经常使用，有分析价值

    预防攻击：
      1. 限流
      2. 反向缓存  长连接-》id，每日过期
