1. 定时任务设计

  
  设计一个订单超时未支付关闭系统：
    1. 扫表轮询：io频繁，消耗资源
    2. 懒删除：  库存不能及时恢复
    3. 消息队列：  延迟队列实现，到期进行消费    可能消息堆积，重启消息队列影响精度
    4. redis：  zset实现延迟任务score放入时间， 定期判断zset头score和当前时间
  
2. 分布式id生成

  ·数据库自增主键
  ·redis incre原子操作

  *雪花算法：64位，时间戳 + 机房id + 机器id + 毫秒级的计数器
  *解决数据库或redis单点问题： 部署多个实例，每个实例初始化值不同， 每次递增的值为实例数，保证id唯一

3. 数据库分库分表

为什么分库：  单机磁盘压力； 并发支持，分成多个功能库
为什么分表：  数据量大慢查询，3层b+树能承载2000万数据，  一般500w开始分表

垂直分库 分表：  根据业务，属性进行拆分
水平分库 分表：  减轻数据库存储 查询压力

水平分库分表策略：
  1. range  有利于扩容， 但可能有热点问题
  2. hash取模  扩容难，但没有热点问题
  3. range+hash先range分库，再hash分表

分库分表问题：
  1.事务问题：不同库需要分布式事务
  2. 排序问题： 需要业务侧合并
  3. 分布式id

4. redis热key，大key问题


5. redis 数据库缓存一致性


6. mysql慢查询


7. 消息队列


8. 限流  


9. 限频，分布式锁


  
10. 下单系统整个流程

    防止订单重复：
      1. 前端防抖
      2. 后端幂等：   ·唯一标识符，如订单号，每次请求会查询该单号是否处理过，可用数据库或缓存记录
                    ·版本号
                    ·状态机
                    ·token机制：  客户端访问服务端，服务端生成token，存储数据库或redis，并返回给客户端；客户端提交订单时附带token，服务端成功处理后会删除token

    解决超卖问题：
      1. 悲观锁，分布式锁

      2. 预扣库存  提交订单的时候就预扣库存，利用redis原子操作

      3. 消息队列，事务消息：

      4. 限流：令牌桶算法

11. 分布式事务

    saga

    tcc

    事务消息

    最大努力交付：短信服务 通知服务，对时间不敏感业务，利用消息队列以及重试机制；    消息队列持久化消息到数据库，监控消息队列，将消息放入延时队列处理，成功标记，失败再放入延时队列
                定时任务进行数据校对，本地事务表
                人工介入

12. 异地多活


13. 海量数据问题

    分治  +  hash  +  小顶堆
    ·海量数据 频率topk：  利用hash记录每个数据访问频次， 堆排序（优先队列）； 如果量级过大，可以对先对数据hash取模，分成多个文件，再对每个文件用hash记录频次， 对每个文件求topk，最后建立堆求整体topk
        
    位图法
    ·海量数据判断是否存在：经典位图法，节省空间；  
    ·判断是否重复出现： 位图法用 00。01。10来标记。10表示多次出现

    海量数据中位数：
    ·内存充足：排序
              数据流中位数，维护两个优先队列

    ·内存不足：分治，转化二进制，根据最高位是否是1分成两个文件， 如果还是不够，再分次高位


