一. 使用场景
	1. 异步处理	避免等待，浪费资源
	2. 解耦生产者消费者		
	3. 削峰		适用高并发场景
	4. 消息驱动的系统

二. 模式
	1. 点对点模式
		·每个消息只有一个消费者
		·生产者和消费者无依赖
		·消费者消费后需要通知消息队列，删除消息

	2. 发布订阅模式
		主题，发布者，订阅者
		·每个消息可能有多个订阅者
		·发布者和订阅者有依赖
		·订阅者需要提前订阅主题，保持在线运行

三. 常见问题
	1. 系统复杂性	*重复消费，消息丢失，消息顺序
	2. 数据一致性	分布式事务
	3. 可用性		高可用设计

	重复消费：有重试机制，消息重发，会影响到下游重复处理。接口幂等
		强校验：事务添加流水表，通过唯一标识对照流水表
		弱校验：不重要的场景，可以用redis记录，可能丢失信息
	顺序消费：1. hash取模法，同一个订单号发送同一个队列 fifo；保证顺序发送


四. 常用
	*1. Kafka 	zookeeper 分区	P2P	大数据实时计算，日志采集
		1. 高吞吐	零拷贝，批处理，数据压缩
		2. 快速持久化
		
	2. RabbitMQ	镜像队列
		1. erlang语言，性能好
		2. 复制设计，延展性差

	*3. RocketMQ	NameServer 	主从架构
		适用主题 分区增加，将消息存储同一物理文件

五. kafka
	zookeeper：树形结构znode（短暂/持久）；  监听
			1. 统一配置管理
			2. 统一命名服务
			3. 分布式锁	创建带顺序号的短暂节点，监听判断自己是不是最小节点
			4. 集群状态	
	
	broker（物理）：一个kafka服务器
	topic（逻辑）：消息队列中的每个队列，有单独命名
	partition（物理）：topic分区，提高topic吞吐量；partition分布在不同broker中；
			每个partition在不同broker有备份，高可用 		

	持久化：将partition数据写入磁盘，只允许顺序写入；pagecache先缓存，等数据足够批量写入磁盘
			
	
	如何消费：消费者组，一个消费者挂掉，其他消费者负责接收；	
		不同消费者组都可以消费整个topic，一个消费者对应一个partition		消费并行
		offset记录消费者消费进度（内部topic），每次消费提交
		zookeeper监控broker 消费者 增删；维护partition主从关系;元数据管理

	消息顺序：通过key,写入partition是顺序的；但全局顺序需要只有一个partition；消费顺序需要只有一个消费者

	
高性能（快）：
	reactor模型
	
	磁盘顺序写入：

	写磁盘buffer：pagecache

	
	零拷贝：sendfile()
		省去了内核缓冲区与用户缓冲区交互，直接内核缓冲区拷贝到socket发送缓冲区。
		DMA引擎技术transferTo()
	
	批量处理和压缩：消息组压缩发送接收	

消息可靠性：
	生产者：3种方法，发送并忘记，同步，异步。 	选择异步回调			ack也分三种 0 1 -1 
			
	*kafka自身：磁盘持久化；   主从分区

		主从同步：	主做读写，从只做备份，从和主有一个落后时间，时间小于一定值认为同步ISR

		高水位机制：	高水位HW：日志已提交最大偏移量（ISR中都包含）		leader的高水位代表了分区的高水位
						leader HW：min（所有isr的leo）。  follower HW： min（自身leo，leader HW）
				LEO:下一条待写入offset

				同步HW的时候，leader故障，可能数据丢失。

				leader epoch：任期号，每次换leader递增。leader故障重启后不再折断hw
				
	
			
	消费者：offset


